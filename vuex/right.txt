<div id="a1"> <h1>全局配置</h1> <p>Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p> </div> <div id="a2"> <h4>silent</h4> <p>类型：boolean</p> <p>默认值：false</p> <p>用法：</p> <pre><div class="hljs"><code class="lang-html"> Vue.config.silent = true </code></div></pre> <p>取消 Vue 所有的日志与警告。</p> </div> <div id="a3"> <h4>optionMergeStrategies</h4> <p>类型：{ [key: string]: Function }</p> <p>默认值：{}</p> <p>用法：</p> <pre><div class="hljs"><code class="lang-html">Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) { return child + 1 } const Profile = Vue.extend({ _my_option: 1 }) // Profile.options._my_option = 2 </code></div></pre> <p>自定义合并策略的选项。</p> <p>合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue 实例上下文被作为第三个参数传入。</p> </div> <div id="a4"> <h4>devtools</h4> <p>类型：boolean</p> <p>默认值：true (生产版为 false)</p> <p>用法：</p> <pre><div class="hljs"><code class="lang-html">// 务必在加载 Vue 之后，立即同步设置以下内容 Vue.config.devtools = true </code></div></pre> <p>配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。</p> </div> <div id="a5"> <h1>全局 API</h1> </div> <div id="a6"> <h4>Vue.extend( options )</h4> <p>参数：</p> <p>{Object} options<br /> 用法：</p> <p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p> <p>data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数</p> <pre><div class="hljs"><code class="lang-html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mount-point"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> </code></div></pre> <pre><div class="hljs"><code class="lang-html"> // 创建构造器 var Profile = Vue.extend({ template: '<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{firstName}} {{lastName}} aka {{alias}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>', data: function () { return { firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' } } }) // 创建 Profile 实例，并挂载到一个元素上。 new Profile().$mount('#mount-point') </code></div></pre> <p>结果如下：</p> <pre><div class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Walter White aka Heisenberg<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> </code></div></pre> </div> <div id="a7"> <h4>Vue.nextTick( [callback, context] )</h4> <p>参数：</p> <pre><div class="hljs"><code class="lang-html">{Function} [callback] {Object} [context] </code></div></pre> <p>默认值：{}</p> <p>用法：</p> <p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <pre><div class="hljs"><code class="lang-html">// 修改数据 vm.msg = 'Hello' // DOM 还没有更新 Vue.nextTick(function () { // DOM 更新了 }) // 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示) Vue.nextTick() .then(function () { // DOM 更新了 }) </code></div></pre> <p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p> </div> <div id="a8"> <h4>Vue.set( target, key, value )</h4> <p>参数：</p> <pre><div class="hljs"><code class="lang-html">{Object | Array} target {string | number} key {any} value </code></div></pre> <p>返回值：设置的值。</p> <p>用法：</p> <p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。</p> </div>